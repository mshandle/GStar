这次课程是这回课程的最后一部分，主要讲Unity的框架搭建。前两节课的内容大概跟大家说了下Unity内部的一些机制主要集中在渲染这块，告诉大家Unity其实本质也就那样。
第二节课的内容跟大家说了下设计模式的基础内容。第三节课呢？我们要结合前面两节课讲的内容。搭一个框架。

搭框架有啥用呢？本质的原因是复用，引擎是基础组件的复用，框架是业务逻辑层复用。

在制作游戏中，有几个东西是难免会涉及到的。UI管理，资源管理，资源管理里面包含了 加载卸载的机制管理，内存的管理。声音的管理，场景管理 网络管理等等一系列的内容。

大家会问，Unity都提供这些了，干嘛还得弄啊。比如Unity 都提供了，UI系统，UGUI，而且商店里面也有NGUI这样的插件，直接用就好了嘛。

这里我要说明的是，组件和框架的区别。Unity 提供的UGUI里面提供了各种组件，但是有些组件不是很满足工作上需求。并且，UGUI只提供了组件，但是对于整个界面的管理是没有。
比如多个界面存着的时候，他的行为是如何，是叠加还是隐藏前面的。帮忙处理一些重复的工作，这样的行为都需要UI控制系统。

2.再讲整个框架搭建之前，最基础是搞定目录。
Assets Unity总的资源目录，脚本也可以认为是资源的一种也需要放在这个目录下。大家应该也不会把资源放在其他外面。

Editor EditorDefault Resoucres Gizmos 这个三个目录都是给编辑器相关用的，从字面上看 Editor Default Resources 
目录是放编辑器资源用的，比如你编辑器需要一个图标都需要放在这个目录下面。
Gizmos 文件夹是放 为了 场景编辑器图片模型资源的目录，大家可能比较少用

说下Editor目录 Unity虽然支持一个Asset 目录下面放多个，而且层级可以放得很深。但是我推荐的把编辑器相关的放在一个目录里面，每个目录根据用途再细分。
最怕编辑器里面加了一个功能要删除的时候 都不知道去哪里找。

Resources目录大家最常用的目录，里面可以放一些资源东西，可以直接通过Resource接口访问，这个目录也是可以支持多个。但是我也是推荐大家只建立一个，再根据资源的类型分类。

Plugins插件目录，如果大家用其他原生的语言了写了类库或者第三方的类库，可以放在这个目录当中。要不然会访问不到

Standard Assets 这个目录字面意思标准资源目录，我们通过Unity Asset Package 导入的默认就放在这里

StreamingAssets 目录这个目录很特殊，它跟Resources目录不一样的一点，放在这个目录内部的资源 不做任何处理的导入到游戏中，你可以放任何类型资源，
全部可以由程序自己控制。我们平常放Resources目录中的资源，其实会压缩，第一次进入游戏的时候会建立文件索引。如果资源很大放在Resources中，其实初始化的时候会很慢。Unity本身也不推荐把资源放在Resources中

这里我也简单的弄个目录大家看下，后期调整大家可以根据具体项目要求。

这里我们建立几个目录，一个是框架层的目录，一个是业务层的目录。框架层目录中可以看到我分了几个，脚本目录，一个插件目录，一个测试单元目录。
脚本里面我们分成核心部分，还是一部分是通用工具。

App...

1.0我们建立框架层，得明白我们一般需求是那些。我刚刚也提到过了几个相关复用组件。等下框架层我们也简单的把这个几个实现下。先从类图开始看

通过上两节课程，这次我们看设计就比较轻松了，这边框架层我简略很多。从大的看，我们这里有个分割线。上面是我们关注的框架层部分，也类似我们以前做的类库部分。
下面就是我们应用层的部分，这里业务层我们比较简单 就一个Application类，继承GameApp。我们的重心关注点在分隔线上部分。

这边我们看到我们框架中，GameApp这是上层稳定模块，底下的这个模块是不稳定的模块。第二节说了，稳定依赖抽象，不要依赖细节。
从类图看到，我们这里建立了抽象BaseComponent类，它是所有组件类的基类。中间只是一个代码的技巧，为了实现组件与单例的混合使用。而且使用了模板方法，添加了一层模板类。

下面就是我们设计的组件类。我们具体看下代码，最基础的BaseComponent类，它的父类是MonoBehavior，为什么要继承它呢？主要我想Unity自带的协程功能，而且组件本身有大量的回调通知。也是由于继承MonoBehavior，其实也带来一些问题。
我后面说，先看BaseComponent，它现在方法很简单正常来说跟 第一节课的游戏原理一样，添加初始化，循环，退出三个虚方法。这样我们就实现了组件最基础的功能。
BaseComponentTemplate 这个模板，看代码就两个方法，这部分实现了单例模式。用模板方法，后面一个，注册实例，这个方法很奇怪，静态私有。后面再GameApp会说到 为什么要这样。

看到这几个文件夹，我们分了几个模块。放在不同的文件夹里面，这样代码目录看着清晰点。随着项目越来越大，目录建立要划分的清晰，每个模块都要方便找得到。

现在到最核心的一块GameApp类，我们这里Awake里面添加一个DontDestory，因为一个GameApp的生命周期是随着整个游戏的。只有到游戏推出，我们才会销毁它。

这边有个初始化方法，我们这里实现类似Unity AddComponent的方法，我们叫AddGameCompnent，为什么不直接用。其实还是刚刚说的 BaseComponentTemplate里面我们需要每次使用不想GetComponent，我们用了一个单例。但是为了封装单例，不想不良的写法破坏了单例。

这里用了一个反射的技巧，强制调用私有的静态。把当前实例赋值给Instance。这边是破坏封装性。这只是相对的，但是对于全局的来说BaseComponentTemplate是封闭的。
我这里注释一部分代码，如果我们自己要实现类似AddComponent和GetComponent呢，传入参数是模板，可以通过模板反射模板的类型，我们得到一个字符串。
我们使用一个字典容器，AddComponent时候，加入容器。GetComponent的时候 通过TypeName 重新获得。
其实从这里也看到一个问题。可能Unity自己实现的AddComponent和GetComponent方法有其他方式，但是性能肯定好不到哪里去。
所以写代码时候不要出现在Update或者FixedUpdate方法里面使用GetComponent方法。

后面几个方法就比较简单，一个初始化所有组件InitComponents方法，这个是通过Awake调用的。其他两个是Unity内建的方法。一个Updata 是ApplicationQuit退出。

到这里我们通过三个类，就把一个小骨架搭起来了。这个骨架比较简单，也没有用非常复杂的设计。接下来，我们要做的事情就是填充血肉。

再开始填充之前得说明一个东西，很多觉得Log日志这种东西，就是平常写代码的时候随便打印一些信息用的。其实日志系统是个很重要的东西。假设一个情况，你在PC上面开发如果有bug还能通过调试查看堆栈信息查bug，
如果你是发布出去的内部测试版本呢，虽然Unity也可以远程调试，但是那个实在慢的没办法用。这时候日志系统就起来非常大的作用。Unity提供的日志方法只能把日志输出到终端，如果手机上，不可能叫每个人测试的时候都连着数据线打印到电脑上。
这时候我们得有自己的一套日志系统，可以自己控制的。这里我们简单的写一个，我们内部定义所有打印日志的地方不使用Unity提供的方法，这里我们就可以拦截日志信息，Application 里面也有一个 Application.logMessageReceived 回调方法也可以转发
这个东西其实可以写的非常复杂，比如你可以自定义一个日志窗口在屏幕上，这样不管是手机或者PC都可以显示当前日志。或者你可以把日志传输到服务器。这样即使不在本地测试，如果有问题也可以看到错误在哪里。
还有我们也可以日志进行分类 错误到一个文件，警告到一个文件，还能对于日志进行格式化，变成XML格式以后做分析方便点。
。但是日志好用也不能滥用，日志唯一要求是写日志少尔精。
不能满屏幕打印一些无关紧要的东西，不要一味的为了红色标红，全部用错误。该是错误就是错误，该是警告就是警告。如果致命错误就得是Error。

看下代码我们这里比较简单，只是拦截了下，最终还是打印出来，只是这里加了一个宏。玩的Unity玩的比较熟的同学会说的。Play 设置里面不是有屏蔽日志输出的吗
我刚刚也说了，这个设置 只是屏蔽了。通过Unity接口输出到终端的。有些日志我们会输出到其他地方。我们用一个Release宏，如果发正式版本的时候。可以把所有的日志屏蔽的。Unity那个开关只能关闭输出到终端的。














