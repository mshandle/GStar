这次课程是这回课程的最后一部分，主要讲Unity的框架搭建。前两节课的内容大概跟大家说了下Unity内部的一些机制主要集中在渲染这块，告诉大家Unity其实本质也就那样。
第二节课的内容跟大家说了下设计模式的基础内容。第三节课呢？我们要结合前面两节课讲的内容。搭一个框架。

搭框架有啥用呢？本质的原因是复用，引擎是基础组件的复用，框架是业务逻辑层复用。

在制作游戏中，有几个东西是难免会涉及到的。UI管理，资源管理，资源管理里面包含了 加载卸载的机制管理，内存的管理。声音的管理，场景管理 网络管理等等一系列的内容。

大家会问，Unity都提供这些了，干嘛还得弄啊。比如Unity 都提供了，UI系统，UGUI，而且商店里面也有NGUI这样的插件，直接用就好了嘛。

这里我要说明的是，组件和框架的区别。Unity 提供的UGUI里面提供了各种组件，但是有些组件不是很满足工作上需求。并且，UGUI只提供了组件，但是对于整个界面的管理是没有。
比如多个界面存着的时候，他的行为是如何，是叠加还是隐藏前面的。帮忙处理一些重复的工作，这样的行为都需要UI控制系统。

2.再讲整个框架搭建之前，最基础是搞定目录。
Assets Unity总的资源目录，脚本也可以认为是资源的一种也需要放在这个目录下。大家应该也不会把资源放在其他外面。

Editor EditorDefault Resoucres Gizmos 这个三个目录都是给编辑器相关用的，从字面上看 Editor Default Resources 
目录是放编辑器资源用的，比如你编辑器需要一个图标都需要放在这个目录下面。
Gizmos 文件夹是放 为了 场景编辑器图片模型资源的目录，大家可能比较少用

说下Editor目录 Unity虽然支持一个Asset 目录下面放多个，而且层级可以放得很深。但是我推荐的把编辑器相关的放在一个目录里面，每个目录根据用途再细分。
最怕编辑器里面加了一个功能要删除的时候 都不知道去哪里找。

Resources目录大家最常用的目录，里面可以放一些资源东西，可以直接通过Resource接口访问，这个目录也是可以支持多个。但是我也是推荐大家只建立一个，再根据资源的类型分类。

Plugins插件目录，如果大家用其他原生的语言了写了类库或者第三方的类库，可以放在这个目录当中。要不然会访问不到

Standard Assets 这个目录字面意思标准资源目录，我们通过Unity Asset Package 导入的默认就放在这里

StreamingAssets 目录这个目录很特殊，它跟Resources目录不一样的一点，放在这个目录内部的资源 不做任何处理的导入到游戏中，你可以放任何类型资源，
全部可以由程序自己控制。我们平常放Resources目录中的资源，其实会压缩，第一次进入游戏的时候会建立文件索引。如果资源很大放在Resources中，其实初始化的时候会很慢。Unity本身也不推荐把资源放在Resources中

这里我也简单的弄个目录大家看下，后期调整大家可以根据具体项目要求。

这里我们建立几个目录，一个是框架层的目录，一个是业务层的目录。框架层目录中可以看到我分了几个，脚本目录，一个插件目录，一个测试单元目录。
脚本里面我们分成核心部分，还是一部分是通用工具。

App...

1.0我们建立框架层，得明白我们一般需求是那些。我刚刚也提到过了几个相关复用组件。等下框架层我们也简单的把这个几个实现下。先从类图开始看

通过上两节课程，这次我们看设计就比较轻松了，这边框架层我简略很多。从大的看，我们这里有个分割线。上面是我们关注的框架层部分，也类似我们以前做的类库部分。
下面就是我们应用层的部分，这里业务层我们比较简单 就一个Application类，继承GameApp。我们的重心关注点在分隔线上部分。

这边我们看到我们框架中，GameApp这是上层稳定模块，底下的这个模块是不稳定的模块。第二节说了，稳定依赖抽象，不要依赖细节。
从类图看到，我们这里建立了抽象BaseComponent类，它是所有组件类的基类。中间只是一个代码的技巧，为了实现组件与单例的混合使用。而且使用了模板方法，添加了一层模板类。

下面就是我们设计的组件类。我们具体看下代码，最基础的BaseComponent类，它的父类是MonoBehavior，为什么要继承它呢？主要我想Unity自带的协程功能，而且组件本身有大量的回调通知。也是由于继承MonoBehavior，其实也带来一些问题。
我后面说，先看BaseComponent，它现在方法很简单正常来说跟 第一节课的游戏原理一样，添加初始化，循环，退出三个虚方法。这样我们就实现了组件最基础的功能。
BaseComponentTemplate 这个模板，看代码就两个方法，这部分实现了单例模式。用模板方法，后面一个，注册实例，这个方法很奇怪，静态私有。后面再GameApp会说到 为什么要这样。

看到这几个文件夹，我们分了几个模块。放在不同的文件夹里面，这样代码目录看着清晰点。随着项目越来越大，目录建立要划分的清晰，每个模块都要方便找得到。

现在到最核心的一块GameApp类，我们这里Awake里面添加一个DontDestory，因为一个GameApp的生命周期是随着整个游戏的。只有到游戏推出，我们才会销毁它。

这边有个初始化方法，我们这里实现类似Unity AddComponent的方法，我们叫AddGameCompnent，为什么不直接用。其实还是刚刚说的 BaseComponentTemplate里面我们需要每次使用不想GetComponent，我们用了一个单例。但是为了封装单例，不想不良的写法破坏了单例。

这里用了一个反射的技巧，强制调用了。把当前实例放进去。这边是破坏封装性。这只是相对的，这边破坏了。但是对于全局的来说还是ok的。我这里注释一部分代码，如果我们自己要实现类似AddComponent和GetComponent呢，传入参数是模板，可以通过模板反射模板的类型，我们得到一个字符串。
我们使用一个字典容器。





