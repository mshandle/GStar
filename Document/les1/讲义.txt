1.大家好，我是来之研发五部的吴保情。这里我要给大家的讲解的主题是 Unity引擎和游戏框架设计。因为不是专业讲课的，有些地方说的不好大家见谅下。

2.我们的课时分成3个部分，五个课时。
第一个课时是带大家了解下Unity引擎。不过这里的我不会跟大家讲解说如何去使用Unity里面的基本组件。
具体组件怎么使用大家还是要去看Document。我们的目的是深入浅出的去了解下，Unity是如何把物体根据我们的操作绘制到屏幕上。就是Unity内部是如何实现的，让大家对于引擎有个概念

第二部分，我们要学习一些游戏开发中的常用设计模式。我们不会全部说软件工程中23种设计模式，会穿插一些游戏开发中的常用设计模式

第三部分，要学习是Untiy游戏基本框架的搭建，结合前面两部学习的知识。整理一套我们自己的Framework层，好了，现在开始第一部分的学习

3 第一部我们是说引擎，那么引擎是什么，最早游戏开发是没有引擎的概念。随着游戏开发越来越多，大家发现一些常用的代码可以整理出来，为了后面游戏开发复用。那么引擎说白了，就是一个代码的工具箱。为了
我们节省一些专业并且重复的工作。我这里提到了专业并且重复！早期游戏开发其实没那么复杂，随着时间的推移，到现在一些3A游戏大作动不动几年开发周期，其实已经相当恐怖了。
制作一个游戏涉及到的专业知识越来越多，人的精力有限不可能在任何方面都相当精通。所以我们其实很大部分的程序员不需要自己会去写专业的组建，我们只要会写业务就好。但是对于引擎了解可以让我们业务写的更好
一般我们游戏分成GamePlay逻辑程序圆和引擎程序员。逻辑程序员就是经常看到专门做业务开发，引擎程序员专门维护引擎。

刚刚说了 一个游戏引擎涉及到知识面很多，最我大概分下。有这几大块。。。 以后大家如何有碰到问题可以直接查看Document，Unity官方文档里面也基本分成这几大块。


谈游戏引擎不能绕过渲染接口层，因为这是最基本部分，我们谈游戏第一直观也是看画面，不是谈玩法。由于各种原因图形接口部分到现在都没有统一。
这里分成三大块，老式的 Linux和开源的阵营的 OpenGL系列。我们现在手机开发基于OpenGLES2.0 3.0 3.1 
微软 PC Xbox用的 DirectX系列 DirectX自己本身不同的版本，架构差别也很多。

还有最近新兴的 苹果自己推的Metal 和开源阵营的 Vulkan

后面我们举得的例子都基于 OpenGL系列说明

4.我们先看这张简单的流程图，初始化设备。。。。，

初始化设备上面说的 我们在不同的平台上用不同的图形接口制作游戏。那么我们就得初始化它。它是最基本的最核心东西。后面调用API都依赖。
并且它依赖与当前平台的，比如Windows就依赖Win32的窗口句柄设备。Java就是当前的Activety。
我们要确保先让它动起来。

初始化数据概念，这是个笼统概念。往小的说 比如我们要渲染时候要到的纹理。
我得先把图片从硬盘加载进内存，选择我们要的纹理格式，后面载入显存。后面显卡才能用的。。。

还有些比如网格数据，材质数据 本地配置等等。

设置渲染状态，OpenGL基于状态机的，设置完某个渲染状态， 这个渲染状态有很多，比如是否开启深度测试，设置裁剪模式，正面裁剪，还是反面裁剪，用什么Shader去绘制图形。 后面渲染都是基于这个状态绘制的。其他平台也大同小异就是API不同。
所以大家有时间可以找个一个平台去学习，DirectX或者OpenGL都可以。

渲染 本身是很复杂的， 这边先说只绘制一个图形。现在我们就可以认为只是调用一个API，就把东西绘制到屏幕上。

后面就是判断测试是否退出了。这就是一个的游戏循环。


5.我们找一个最简单的OpenGLdemo看下 大概的代码

前面四行，都是在初始化设备的概念。不同的平台代码量不一样，比如这个使用了第三方库glf，只要几行代码就可以初始化一个窗口。

从后面到while循环前面这部分，都可以认为是初始化数据部分。

这边是个while，里面一直清理后备缓存，设置渲染状态，渲染，交换前后台缓存、

从while这里我们了解一个非常基本的概念，游戏不是说 我们做出概念才会重新绘制，其实是一直在后台绘制。这里还有概念，我们一秒跑多少次while循环，渲染出多少次就叫多少帧。



6.如果我们在Unity实现这个窗口到多久呢，其实都不用写代码，拖拖几个组建就可以实现了。
(打开Unity,删除多余组建)

//看下几个核心的东西，对应到上面的OpenGL代码 Quad  MeshFilter Material MeshRender

MeshFilter 我们可以认认为始化上面的网格数据部分代码 ，Material 可以认为设置渲染流程。Material里面包含我们要使用的贴图，一些常量，还是有Shader。 Shader是可编程管线里面最重要的部分。如果大家没有概念的话。我这个做个不准确的比喻
如果前面的贴图，常量都是做饭的材料话。那么Shader就是描述如何炒菜步骤的菜谱。
我们这里面就一个常量Color
MeshRender可以认为就是glDrawArray。
其他部分比如说初始化设备，整个游戏while循环unity已经帮我们处理好了。我这里只要往各个步骤里面插入我们的东西。就可以了。

到这里可以看到，对比我们自己直接从OpenGL写绘制一个图形，Unity把一些东西抽象出来。重复性的东西封装好。我们用起来非常方便，而且所见即所得。
(拖两个模型)

这里提下 比如我们渲染两个物体 A B A是红色，B是蓝色。在渲染时候，我们要设置A的渲染的Shader里面的Color常量，渲染A，再设置B的颜色常量。渲染B。
在后面开发工作中，我们一直会提到一个渲染概念DrawCall，它是非常重要的渲染性能指标。如果大家有时间可以去深入了解下。但是这里可以说一个理念。渲染状态的切换的消耗，大于渲染提交的消耗。

7刚刚我们也谈到渲染 我们前面说可以单纯认为一个调用渲染接口。但是我们场景比较复杂，物件比较多的话，我们这样直接调用API，不是特别合适。而且我们在做Untiy没看到说任何跟渲染平台相关的代码这是为什么呢？

第一：Unity为了跨平台的特使，抽象了渲染接口。不同的平台在对于渲染的接口进行具体的实现。
第二：对于渲染本身的抽象。早些年的引擎可能没有对于渲染的抽象，比如开源Cocos2d引擎。早些年版本里面，我们在Sprite里面就可以看到直接调用OpenGL的代码。这里其实有个不好的地方、后面设计模式也有提到。就是不好修改。
比如渲染一个静态模型，跟渲染粒子特效。其实很大一部分的代码都是一样的，可能就小部分不同。如果直接写的话。我们就得重新写很多代码。就是代码的复用性不好。
第三点，性能，直接的写的性能会比较差，我刚刚也提到过了。渲染状态的切换的消耗，大于渲染提交的消耗。如果上下文紧接的渲染两个模型，我们用相同的材质，相同的网格，相同的贴图，里面就一个颜色不同的话。
如果我们直接写的话，按照上面的流程图，我们就得重新设置渲染的状态，设置材质，设置贴图，设置Shader，设置颜色。调用渲染。这里面其实有很多重复没必要的操作。
比如材质，贴图 Shader

Unity里面抽象的了一个叫render实体概念。我看下 类图。最基础的类就是Untiy本身的Object Render继承Object，最左边我们常用到的 MeshRender继承于Render，里面依赖的了 MeshFilter，MeshFilter 依赖了一个Mesh。
我们把这些Render放在一个队列里面，这个队列我们一般称为渲染队列。我们会根据队列的里面的每个模型的材质特性，做一次渲染排序。把状态切换最小的渲染实体就近排序。这样保证最小的渲染状态切换。这样才是高性能的渲染。

8 一次渲染的过程，可能包含多个渲染队列。不同的摄像机 不同的灯光，透明非透明都会产生分支。多一个分支就可以认为多一个渲染队列。现在我们不谈的延迟渲染结构，普通向前的渲染架构。
如果只有一个摄像机存在的情况，场景中没有灯光或者只有一盏的灯，只有不透明的话，只有一个渲染队列。
如果有半透明的话，透明和不透明是分成两个渲染队列，如果有两台摄像机的话。那么就有乘2。如果多1盏灯光就就继续加倍。
灯光不会增加渲染队列，但是灯光是实时的话，对于受到这个灯光影响的物件，在向前渲染架构下。比如一个物件受到一盏渲染一次就够，如果受到两盏灯就得渲染两次。

前面的我们提到了 DrawCall是一个非常重要评估的渲染性能的指标。只是因为早些的图形接口驱动设计的问题。大量性能消耗的在渲染状态切换上面。
继续做个比喻，加入我们要搬家，家里有很多家具。形状奇奇怪怪的，我叫来一辆车。摆放不好的话可能需要多辆车，那么整个搬家的过程就很慢。

如果对于渲染控制不好就性能很差，这里面我的性能差 现在只谈在CPU端，GPU端我们现在先不讨论。有了渲染队列之后，我们对渲染实体排序。如果上下文渲染一模一样我们就可以合并网格 就是上面提到的顶点数据
Unity本身也提供了两种机制一中叫Static Batching 一种叫Dynamic Bacting，字面上了解，静态合并批次和动态合并批次。静态合并批次就是这个物件在场景中是静态的。不做任何的位移变动，动态合并批次，可以对于动态物体合并
Static Batching 在初始化合并数据就好， Dynamic Batchin 每帧都会重新计算。所以静态合并批次性能更好点。还有一种技术是GPU Instance技术。
就是大部分渲染状态一样，小部分渲染状态不同的数据放到一个类似数组的地方整个传给GPU，对于GPU来说都是一样的材质。在GPU中使用不同的参数渲染。这样驱动少干预一点，性能就提高了。

渲染功能大概就是这样，但是我们可以使用API，组合不同的渲染状态。可以做出非常多的效果。比如阴影：在方向光下，我们首先在灯光的空间下，渲染一次所有物件的深度图，
第二次渲染的时候，判断当前深度跟深度图深度比较，如果小于就说明被挡住了，在阴影内。这就是ShadowMap的基本原理。其他阴影技术，就是在阴影图和采样阴影的深度图的技术做变种。

这里做个实际小测试。(打开场景拖两个QUAd) Play看下，Batching的数量 默认下 只有两个Batching如果拷贝一份呢。3 如果拷贝10个呢

一般对于Batching的数量，有个控制范围。Navida 有篇文章大概这样说：主频对应DrawCall数量2G主频控制在200 2.5G对应250个。
这边只谈CPU端。渲染的性能好不好就跟木桶一样。最短的一根决定的。GPU如果慢啦也会拖累整个循环的变慢。

到这里对于Untiy的渲染流程我们就会有个大概的了解。2D 3D是通用的，如果有时间后面我们深入的讲解下渲染管线的部分知识。

9刚刚说了那么多，我一直在While渲染里面。现在我们要跳到初始化数据部分。Unity让我们感觉好用的地方，也是在于它初始化数据的部分。各种组件拖拉，直接在编辑器上面填入要用的数据。
如果做个简单的游戏 PlayerMaker这样的组件拖拉逻辑都能满足需求。而且各种组件可以灵活的组织起来。我们可以把通用的代码用组件式的封装。我们这里继续用一个流程图梳理下。
一开始也是初始化Unity核心的基础组件，这部分我们是概念不了。第二步我们要解析场景文件，第三部分构建场景树，最后就是实例化场景。

(打开场景 编辑两个物件)
10从场景文件













